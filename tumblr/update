#!/usr/bin/env ruby

require 'open-uri'
require 'digest/md5'
require 'nokogiri'
require 'fileutils'
require 'pathname'
require 'json'
require 'uri'
require 'clive/output'
require 'tumblr_client'
require 'seq/paged'

HERE = Pathname.new(__FILE__) + '..'

Tumblr.configure do |config|
  config.consumer_key        = ENV['TUMBLR_CONSUMER_KEY']
  config.consumer_secret     = ENV['TUMBLR_CONSUMER_SECRET']

  # Need to use an _auth file like flickr!
  config.oauth_token         = "bB8tceY9hMBzvsn9E38qb6c0QoZBp8w0tblFVm9DeN8i3vihwM"
  config.oauth_token_secret  = "itKKT3F5HKhlGCnKXsHjA0II2Q9hYERTARws57fhXSVOV5i14I"
end

module Url
  def to_local(url)
    url.split('://').last
  end

  def to_remote(path)
    'http://' + path
  end
end

class Resource
  def initialize(post, url)
    @post = post
    @url  = url
  end

  def path
    @post.path + (Digest::MD5.hexdigest(@url) + File.extname(@url))
  end

  def write
    unless File.exist?(path)
      open(@url) {|f| File.write(path, f.read) }
      puts '  wrote '.grey + path.basename.to_s
    end
  rescue OpenURI::HTTPError => err
    puts "  ERROR ".red.bold + @url + "\n    " + err.to_s
  end
end

class Post
  def initialize(blog, hash)
    @blog = blog
    @hash = hash
  end

  def to_json
    JSON.pretty_generate(@hash)
  end

  def id
    @hash['id']
  end

  def path
    @blog.path + 'posts' + id.to_s
  end

  def type
    @hash['type']
  end

  def resources
    return @resources if @resources

    @resources = []

    pull_from = -> string {
      doc = Nokogiri::HTML(string)
      doc.xpath('//img/@src').map(&:value)
    }

    case type
    when 'photo'
      @resources = @hash['photos'].map {|hsh| hsh['original_size']['url'] }

    when 'link'
      @resources = pull_from[@hash['description']]

    when 'video'
      @resources = [] # could download the video, but will be too much work

    when 'text'
      @resources = pull_from[@hash['body']]

    when 'quote'
      @resources = pull_from[@hash['text']] + pull_from[@hash['source']]

    when 'chat'
      @resources = pull_from[@hash['body']]

    when 'audio'
      plead = '?plead=please-dont-download-this-or-our-lawyers-wont-let-us-host-audio'
      @hash['player'] =~ /audio_file=([^&]*)/
      @resources = [URI.unescape($1) + plead]
    end

    @resources.map! {|url| Resource.new(self, url) }
  end

  def write
    puts path.to_s.blue.bold

    unless File.exist?(path + 'data.json')
      FileUtils.mkdir_p(path)
      File.write(path + 'data.json', to_json)
      puts '  wrote '.grey + 'data.json'
    end

    resources.each(&:write)
  end
end

class Tumblelog
  def initialize(client, data)
    @client = client
    @data   = data
  end

  def name
    @data['name']
  end

  def to_json
    JSON.pretty_generate @data
  end

  def path
    HERE + name
  end

  def posts
    @posts ||= Seq::Paged.new do |page|
      opts = {
        limit: 20,  # max.
        offset: page * 20,
        reblog_info: true,
        notes_info: true
      }

      @client.posts(name, opts)['posts'].map {|post| Post.new(self, post)}
    end
  end

  def write
    puts path.to_s.blue.bold

    unless File.exist?(path + 'data.json')
      FileUtils.mkdir_p(path)
      File.write(path + 'data.json', to_json)
      puts '  wrote '.grey + 'data.json'
    end

    posts.each {|post| post.write if post }
  end
end


client = Tumblr::Client.new
info   = client.info

blogs  = info['user']['blogs'].map do |data|
  Tumblelog.new(client, data)
end

blogs.each(&:write)
