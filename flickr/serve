#!/usr/bin/env ruby

gem 'sass'; require 'sass'
require 'haml'
require 'json'
require 'time'
require 'maruku'
require 'sinatra'
require 'seq/pager'

PAGE_SIZE = 10
HERE = Pathname.new(__FILE__) + '..'
set :public_folder, File.dirname(__FILE__)
set :views, File.dirname(__FILE__) + '/app'

module F; end

# Requires #photos method to be defined
module F::Pageable
  def __pages
    ivar = self.instance_variable_get(:@__pages)
    return ivar if ivar
    self.instance_variable_set(:@__pages, Seq::Pager.new(PAGE_SIZE, photos))
  end

  def page(num)
    __pages.page = num
    __pages.curr
  end

  def page_count
    __pages.pages
  end

  def range
    __pages.range(2, 2, 2)
      .reject(&:empty?)
      .map {|a| a << nil }
      .flatten.tap(&:pop)
  end
end

class F::Photo
  attr_reader :id

  def initialize(user, id)
    @user  = user
    @id    = id
  end

  def name
    data['title']
  end

  def sort_date
    Time.at(data["dateuploaded"].to_i)
  end

  def index
    @user.index_of(self)
  end

  def prev
    @prev ||= begin
                return if index <= 0
                @user.find_by_index(index - 1)
              end
  end

  def next
    @next ||= begin
                return if index >= @user.photos.size - 1
                @user.find_by_index(index + 1)
              end
  end

  def path
    @user.path + 'photos' + @id.to_s
  end

  def url
    @user.url + "/#{id}"
  end

  def original_url
    '/' + Pathname.glob(path + 'photo_o.*').first.relative_path_from(HERE).to_s
  end

  def thumbnail_url
    '/' + path.relative_path_from(HERE).to_s + '/photo_z.jpg'
  end

  def data
    @data ||= JSON.parse File.read(path + 'data.json')
  end

  def exif
    @exif ||= JSON.parse File.read(path + 'exif.json')
  end

  def has_exif?(name)
    get_exif(name) != nil
  end

  def get_exif(name)
    exif['exif'].find {|t| t['label'] == name || t['tag'] == name }
  end

  def inspect
    "#<F::Photo #{@id}>"
  end

  def method_missing(sym, *args, &block)
    if data.key?(sym.to_s)
      data[sym.to_s]
    else
      super
    end
  end
end

class F::Set
  include F::Pageable

  attr_reader :id

  def initialize(user, id)
    @user = user
    @id   = id
  end

  def name
    data['title']
  end

  def path
    @user.path + 'sets' + id.to_s
  end

  def url
    @user.url + '/sets/' + id.to_s
  end

  def photos
    @photos ||= data['photos'].reverse.map {|ph| @user.photo(ph) }
  end

  def data
    @data ||= JSON.parse File.read(path + 'data.json')
  end

  def inspect
    "#<F::Set #@id>"
  end
end

class F::Tag
  include F::Pageable

  attr_reader :name

  def initialize(user, ids, name)
    @user = user
    @ids  = ids
    @name = name
  end

  def photos
    @photos ||= @ids.map {|ph| @user.photo(ph)}
  end

  def url
    @user.url + '/tags/' + @name
  end

  def inspect
    "#<F::Tag #@name>"
  end
end

class F::Camera
  include F::Pageable

  attr_reader :name

  def initialize(user, ids, name)
    @user = user
    @ids  = ids
    @name = name
  end

  def escaped_name
    @name.downcase.gsub(' ', '-')
  end

  def photos
    @photos ||= @ids.map {|ph| @user.photo(ph) }
  end

  def url
    @user.url + '/cameras/' + escaped_name
  end

  def inspect
    "#<F::Camera #@name>"
  end
end

class F::User
  include F::Pageable

  def self.all
    Dir[HERE + '*@*'].map {|path|
      new path.split('/').last
    }
  end

  # term could be an id (nsid) or path_alias.
  def self.find(term)
    all.find {|user|
      user.data['id'] == term || user.data['path_alias'] == term
    }
  end

  attr_reader :id

  def initialize(id)
    @id = id
  end

  def name
    data['username']
  end

  def path
    HERE + @id.to_s
  end

  def data
    @data ||= JSON.parse File.read(path + 'data.json')
  end

  def url
    "/photos/#{id}"
  end

  def url_for_page(num)
    "/photos/#{id}/page/#{num}"
  end

  def index_of(photo)
    photos.index(photo)
  end

  def find_by_index(index)
    photos[index]
  end

  def cameras
    # p user.photos.first.exif['camera']
    # p user.photos.first.get_exif('Make')
    # p user.photos.first.get_exif('Model')

    return @cameras if @cameras

    @cameras = Hash.new([])
    photos.each do |photo|
      camera = photo.exif['camera']
      if camera && !camera.empty?
        @cameras[camera] += [photo.id]
      end
    end

    @cameras = @cameras.map {|k,v| F::Camera.new(self, v, k) }
  end

  def tags
    return @tags if @tags

    @tags = Hash.new([])
    photos.each do |photo|
      photo.data['tags']['tag'].each do |tag|
        @tags[tag['_content']] += [photo.id]
      end
    end

    @tags = @tags.map {|k,v| F::Tag.new(self, v, k) }
  end

  def sets
    @sets ||= Dir[path + 'sets' + '*'].map {|dir|
      F::Set.new(self, dir.split("/").last.to_i)
    }.compact
  end

  def photos
    @photos ||= Dir[path + 'photos' + '*'].map {|path|
      F::Photo.new(self, path.split("/").last.to_i)
    }.sort_by(&:sort_date).reverse
  end

  def photo(id)
    photos.find {|ph| ph.id == id.to_i }
  end

  def camera(name)
    cameras.find {|ca| ca.escaped_name == name }
  end

  def set(id)
    sets.find {|st| st.id == id.to_i }
  end

  def tag(name)
    tags.find {|tg| tg.name == name }
  end

  def inspect
    "#<User #@id>"
  end
end


def time(msg, &block)
  s = Time.now
  block.call
  puts "#{msg}: #{Time.now - s}s"
end


helpers do
  def title(*parts)
    parts = %w(flickr) + parts.map {|part|
      part.respond_to?(:name) ? part.name : part
    }
    parts.join(" / ")
  end

  def meta(user, photo)
    time = Time.parse(photo.dates['taken']) # Time.at(photo.dateuploaded.to_i)

    # nicked from parallel-flickr, because it's nice
    # straup/parallel-flickr/www/include/lib_flickr_dates.php
    hour = case time.hour
           when 0..6 then "after midnight"
           when 6..8 then "in the wee small hours of the morning"
           when 8..12 then "in the morning"
           when 12..14 then "around noon"
           when 14..18 then "in the afternoon"
           when 18..20 then "in the evening"
           else "at night"
           end

    ordinal = case time.day
              when 1, 21 then "st"
              when 2, 22 then "nd"
              else "th"
              end

    day = time.strftime("%A %B %-d") + ordinal + time.strftime(" %Y")

    <<EOS
<time datetime="#{time.strftime("%FT%T%:z")}">#{day}, #{hour}</time>
EOS
  end

  def partial(page, options={})
    haml "partials/#{page}".to_sym, options.merge(:layout => false)
  end
end


get '/styles.css' do
  sass :styles
end

get '/photos/:user/?' do
  @user = F::User.find(params[:user])
  @page = 0
  @photos = @user.page(@page)
  haml :photos
end

get '/photos/:user/page/:num/?' do
  @user = F::User.find(params[:user])
  @page = params[:num].to_i

  redirect @user.url if @page == 0

  @photos = @user.page(@page)
  haml :photos
end


get '/photos/:user/cameras/?' do
  @user = F::User.find(params[:user])
  @cameras = @user.cameras

  haml :cameras
end

get '/photos/:user/cameras/:camera/?' do
  @user   = F::User.find(params[:user])
  @camera = @user.camera(params[:camera])
  @page   = 0
  @photos = @camera.page(@page)

  haml :camera
end

get '/photos/:user/cameras/:camera/page/:num/?' do
  @user   = F::User.find(params[:user])
  @camera = @user.camera(params[:camera])
  @page   = params[:num].to_i
  @photos = @camera.page(@page)

  redirect @camera.url if @page == 0

  haml :camera
end

get '/photos/:user/sets/?' do
  @user = F::User.find(params[:user])
  @sets = @user.sets

  haml :sets
end

get '/photos/:user/sets/:set/?' do
  @user   = F::User.find(params[:user])
  @set    = @user.set(params[:set])
  @page   = 0
  @photos = @set.page(@page)

  haml :set
end

get '/photos/:user/sets/:set/page/:num/?' do
  @user   = F::User.find(params[:user])
  @set    = @user.set(params[:set])
  @page   = params[:num].to_i
  @photos = @set.page(@page)

  haml :set
end

get '/photos/:user/tags/?' do
  @user = F::User.find(params[:user])
  @tags = @user.tags

  haml :tags
end

get '/photos/:user/tags/:tag/?' do
  @user = F::User.find(params[:user])
  @tag  = @user.tag(params[:tag])

  haml :tag
end

get '/photos/:user/:photo/?' do
  @user = F::User.find(params[:user])
  @photo = @user.photo(params[:photo])

  haml :photo
end
