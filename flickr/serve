#!/usr/bin/env ruby

gem 'sass'; require 'sass'
require 'haml'
require 'json'
require 'time'
require 'maruku'
require 'sinatra'
require 'seq/pager'

PAGE_SIZE = 10
HERE = Pathname.new(__FILE__) + '..'
set :public_folder, File.dirname(__FILE__)
set :views, File.dirname(__FILE__) + '/app'

module F; end

# Requires #photos method to be defined
module F::Pageable
  def __pages
    ivar = self.instance_variable_get(:@__pages)
    return ivar if ivar
    self.instance_variable_set(:@__pages, Seq::Pager.new(PAGE_SIZE, photos))
  end

  def page(num)
    __pages.page = num
    __pages.curr
  end

  def page_count
    __pages.pages
  end

  def range
    __pages.range(2, 2, 2)
      .reject(&:empty?)
      .map {|a| a << nil }
      .flatten.tap(&:pop)
  end
end

class F::GenericPageable
  include F::Pageable
  attr_reader :url, :photos

  def initialize(url, photos)
    @url = url
    @photos = photos
  end
end


class F::Photo
  attr_reader :id

  def initialize(user, id)
    @user  = user
    @id    = id
  end

  def name
    data['title']
  end

  def sort_date
    Time.at(data["dateuploaded"].to_i)
  end

  def index
    @user.index_of(self)
  end

  def prev
    @prev ||= begin
                return if index <= 0
                @user.find_by_index(index - 1)
              end
  end

  def next
    @next ||= begin
                return if index >= @user.photos.size - 1
                @user.find_by_index(index + 1)
              end
  end

  def path
    @user.path + 'photos' + @id.to_s
  end

  def url
    @user.url + "/#{id}"
  end

  def original_url
    name = Pathname.glob(path + 'photo_o.*').first
    return thumbnail_url unless name
    '/' + name.relative_path_from(HERE).to_s
  end

  def thumbnail_url
    '/' + path.relative_path_from(HERE).to_s + '/photo_z.jpg'
  end

  def data
    @data ||= JSON.parse File.read(path + 'data.json')
  end

  def exif
    @exif ||= JSON.parse File.read(path + 'exif.json')
  rescue
    {}
  end

  def has_exif?(name)
    get_exif(name) != nil
  end

  def get_exif(name)
    exif['exif'].find {|t| t['label'] == name || t['tag'] == name }
  end

  def inspect
    "#<F::Photo #{@id}>"
  end

  def method_missing(sym, *args, &block)
    if data.key?(sym.to_s)
      data[sym.to_s]
    else
      super
    end
  end
end

class F::ExtendedPhoto < F::Photo
  attr_reader :extended_data

  def initialize(user, id, extended_data)
    @user = user
    @id = id
    @extended_data = extended_data
  end
end


class F::Set
  include F::Pageable

  attr_reader :id

  def initialize(user, id)
    @user = user
    @id   = id
  end

  def name
    data['title']
  end

  def path
    @user.path + 'sets' + id.to_s
  end

  def url
    @user.url + '/sets/' + id.to_s
  end

  def photos
    @photos ||= data['photos'].reverse.map {|ph| @user.photo(ph) }
  end

  def data
    @data ||= JSON.parse File.read(path + 'data.json')
  end

  def inspect
    "#<F::Set #@id>"
  end
end

class F::Tag
  include F::Pageable

  attr_reader :name

  def initialize(user, ids, name)
    @user = user
    @ids  = ids
    @name = name
  end

  def photos
    @photos ||= @ids.map {|ph| @user.photo(ph)}
  end

  def url
    @user.url + '/tags/' + @name
  end

  def inspect
    "#<F::Tag #@name>"
  end
end

class F::Camera
  include F::Pageable

  def initialize(user, ids, make, model)
    @user  = user
    @ids   = ids
    @make  = make
    @model = model
  end

  def name
    @make + " " + @model
  end

  def escaped_name
    name.downcase.gsub(' ', '-')
  end

  def photos
    @photos ||= @ids.map {|ph| @user.photo(ph) }
  end

  def url
    @user.url + '/cameras/' + escaped_name
  end

  def inspect
    "#<F::Camera #{name}>"
  end
end

class F::Place
  include F::Pageable

  attr_reader :data

  def initialize(user, data)
    @user = user
    @data = data
    @ids  = []
  end

  def << photo
    @ids += [photo.id]
  end

  def id
    @data['woeid']
  end

  def name
    @data['_content']
  end

  def photos
    @photos ||= @ids.map {|ph| @user.photo(ph) }
  end

  def url
    @user.url + '/places/' + id
  end

  def inspect
    "#<F::Place #{name}>"
  end
end

class F::User
  include F::Pageable

  def self.all
    @all ||= Dir[HERE + '*@*'].map {|path|
      new path.split('/').last
    }
  end

  # term could be an id (nsid) or path_alias.
  def self.find(term)
    all.find {|user|
      user.id == term || user.data['path_alias'] == term
    }
  end

  attr_reader :id

  def initialize(id)
    @id = id
  end

  def name
    data['username']
  end

  def path
    HERE + @id.to_s
  end

  def data
    if (path + 'data.json').exist?
      @data ||= JSON.parse File.read(path + 'data.json')
    else
      {}
    end
  end

  def url
    "/photos/#{id}"
  end

  def url_for_page(num)
    "/photos/#{id}/page/#{num}"
  end

  def index_of(photo)
    photos.index(photo)
  end

  def find_by_index(index)
    photos[index]
  end

  def cameras
    return @cameras if @cameras

    @cameras = {}
    photos.each do |photo|
      make  = photo.get_exif('Make')
      model = photo.get_exif('Model')

      if make && !make.empty? && model && !model.empty?
        make = make['raw'].strip; model = model['raw'].strip
        @cameras[make] ||= {}
        @cameras[make][model] ||= []
        @cameras[make][model]  += [photo.id]
      end
    end

    @cameras = @cameras.map {|make, models|
      models.map {|model, ids|
        F::Camera.new(self, ids, make, model)
      }
    }.flatten
  end

  def camera(name)
    cameras.find {|ca| ca.escaped_name == name }
  end


  def faves
    return @faves if @faves

    faves = Dir[path + 'favorites' + '*'].map {|dir|
      JSON.load File.read(dir + '/data.json')
    }.sort_by {|data| -data['date_faved'].to_i }.map {|data|
      user = F::User.find(data['owner'])
      F::ExtendedPhoto.new(user, data['id'], data)
    }

    @faves = F::GenericPageable.new(self.url + '/faves', faves)
  end


  def tags
    return @tags if @tags

    @tags = Hash.new([])
    photos.each do |photo|
      photo.data['tags']['tag'].each do |tag|
        @tags[tag['_content']] += [photo.id]
      end
    end

    @tags = @tags.map {|k,v| F::Tag.new(self, v, k) }
  end

  def tag(name)
    tags.find {|tg| tg.name == name }
  end

  def sets
    @sets ||= Dir[path + 'sets' + '*'].map {|dir|
      F::Set.new(self, dir.split("/").last.to_i)
    }.compact
  end

  def set(id)
    sets.find {|st| st.id == id.to_i }
  end

  def photos
    @photos ||= Dir[path + 'photos' + '*'].map {|path|
      F::Photo.new(self, path.split("/").last.to_i)
    }.sort_by(&:sort_date).reverse
  end

  def photo(id)
    photos.find {|ph| ph.id == id.to_i }
  end

  def places
    return @places if @places

    @places = {}
    levels = %w(neighbourhood locality county region country)

    photos.each do |photo|
      next unless loc = photo.data['location']

      levels.each do |level|
        next unless data = loc[level]

        @places[data['woeid']] ||= F::Place.new(self, data)
        @places[data['woeid']] << photo
      end
    end

    @places = @places.map {|_,v| v }
  end

  def place(woeid)
    places.find {|pl| pl.id == woeid }
  end

  def inspect
    "#<F::User #@id>"
  end
end


def time(msg, &block)
  s = Time.now
  block.call
  puts "#{msg}: #{Time.now - s}s"
end


helpers do
  def title(*parts)
    parts = %w(flickr) + parts.map {|part|
      part.respond_to?(:name) ? part.name : part
    }
    parts.join(" / ")
  end

  def partial(page, options={})
    haml "partials/#{page}".to_sym, options.merge(:layout => false)
  end
end

class Time
  # nicked from parallel-flickr, because it's nice
  # straup/parallel-flickr/www/include/lib_flickr_dates.php
  def descriptive_hour
    case hour
    when 0..6 then "after midnight"
    when 6..8 then "in the wee small hours of the morning"
    when 8..12 then "in the morning"
    when 12..14 then "around noon"
    when 14..18 then "in the afternoon"
    when 18..20 then "in the evening"
    else "at night"
    end
  end

  def ordinal
    case day
    when 1, 21 then "st"
    when 2, 22 then "nd"
    else "th"
    end
  end
end


get '/styles.css' do
  sass :styles
end

get '/photos/:user/?' do
  @user = F::User.find(params[:user])
  @page = 0
  @photos = @user.page(@page)
  haml :photos
end

get '/photos/:user/page/:num/?' do
  @user = F::User.find(params[:user])
  @page = params[:num].to_i

  redirect @user.url if @page == 0

  @photos = @user.page(@page)
  haml :photos
end


get '/photos/:user/faves/?' do
  @user   = F::User.find(params[:user])
  @faves  = @user.faves
  @page   = 0
  @photos = @faves.page(@page)

  haml :faves
end

get '/photos/:user/faves/page/:num/?' do
  @user   = F::User.find(params[:user])
  @faves  = @user.faves
  @page   = params[:num].to_i
  @photos = @faves.page(@page)

  redirect @user.url + '/faves' if @page == 0

  haml :faves
end


get '/photos/:user/cameras/?' do
  @user = F::User.find(params[:user])
  @cameras = @user.cameras

  haml :cameras
end

get '/photos/:user/cameras/:camera/?' do
  @user   = F::User.find(params[:user])
  @camera = @user.camera(params[:camera])
  @page   = 0
  @photos = @camera.page(@page)

  haml :camera
end

get '/photos/:user/cameras/:camera/page/:num/?' do
  @user   = F::User.find(params[:user])
  @camera = @user.camera(params[:camera])
  @page   = params[:num].to_i
  @photos = @camera.page(@page)

  redirect @camera.url if @page == 0

  haml :camera
end


get '/photos/:user/places/?' do
  @user = F::User.find(params[:user])
  @places = @user.places

  haml :places
end

get '/photos/:user/places/:woeid/?' do
  @user   = F::User.find(params[:user])
  @place  = @user.place(params[:woeid])
  @page   = 0
  @photos = @place.page(@page)

  haml :place
end

get '/photos/:user/places/:woeid/page/:num?' do
  @user   = F::User.find(params[:user])
  @place  = @user.place(params[:woeid])
  @page   = params[:num].to_i
  @photos = @place.page(@page)

  redirect @place.url if @page == 0

  haml :place
end


get '/photos/:user/sets/?' do
  @user = F::User.find(params[:user])
  @sets = @user.sets

  haml :sets
end

get '/photos/:user/sets/:set/?' do
  @user   = F::User.find(params[:user])
  @set    = @user.set(params[:set])
  @page   = 0
  @photos = @set.page(@page)

  haml :set
end

get '/photos/:user/sets/:set/page/:num/?' do
  @user   = F::User.find(params[:user])
  @set    = @user.set(params[:set])
  @page   = params[:num].to_i
  @photos = @set.page(@page)

  redirect @set.url if @page == 0

  haml :set
end


get '/photos/:user/tags/?' do
  @user = F::User.find(params[:user])
  @tags = @user.tags

  haml :tags
end

get '/photos/:user/tags/:tag/?' do
  @user   = F::User.find(params[:user])
  @tag    = @user.tag(params[:tag])
  @page   = 0
  @photos = @tag.page(@page)

  haml :tag
end

get '/photos/:user/tags/:tag/page/:num' do
  @user   = F::User.find(params[:user])
  @tag    = @user.tag(params[:tag])
  @page   = params[:num].to_i
  @photos = @tag.page(@page)

  redirect @tag.url if @page == 0

  haml :tag
end


get '/photos/:user/:photo/?' do
  @user  = F::User.find(params[:user])
  @photo = @user.photo(params[:photo])

  haml :photo
end
