#!/usr/bin/env ruby

# Steps:
#  - download and store original photos and their "640x" versions
#  - download and store contents of `flickr.photos.getInfo` as a JSON file
#  - generate a photostream, dynamically, using sinatra

require 'fileutils'
require 'json'
require 'pathname'
require 'open-uri'
require 'pp'
require 'clive/output'
require 'flickraw'
require 'seq/paged'

HERE = Pathname.new(__FILE__) + '..'

class FlickRaw::Response
  # The built in #to_hash method doesn't do this deep stuff!
  def to_h
    h = to_hash.map {|k,v|
      if v.respond_to?(:to_h)
        [k, v.to_h]
      elsif v.respond_to?(:map) && v.all? {|obj| obj.respond_to?(:to_h) }
        [k, v.map(&:to_h)]
      else
        [k, v]
      end
    }
    Hash[h]
  end
end

module Helper extend self
  # Runs the standard authenticartion flow. This involves printing a url and
  # waiting for the number given by it. When we have the tokens, we save them to
  # a local file so that they can be read, which saves having to authenticate
  # properly every time. Though it probably is not great for security...
  def run_authentication_flow
    token = flickr.get_request_token
    auth_url = flickr.get_authorize_url(token['oauth_token'])

    puts "Open this url in your process to complete the authication process : #{auth_url}"
    puts "Copy here the number given when you complete the process."
    verify = gets.strip

    begin
      flickr.get_access_token(token['oauth_token'], token['oauth_token_secret'], verify)
      login = flickr.test.login
      puts "You are now authenticated as #{login.username} with token #{flickr.access_token} and secret #{flickr.access_secret}"
      File.write(HERE + '_auth', "#{flickr.access_token}\n#{flickr.access_secret}")

    rescue FlickRaw::FailedResponse => e
      puts "Authentication failed : #{e.msg}"
      exit
    end
  end

  # If we've already been authenticated, use those details, otherwise get some
  # new ones.
  def authenticate
    if File.exist?(HERE + '_auth')
      details = File.read(HERE + '_auth').split("\n")

      flickr.access_token = details[0]
      flickr.access_secret = details[1]
    end

    run_authentication_flow unless login
  end

  def test_login
    if login
      puts "You are authenticated as #{login.username}"
    else
      puts "You are not authenticated"
    end
  end

  def login
    @login ||= flickr.test.login
  rescue FlickRaw::OAuthClient::FailedResponse
    false
  end
end


class Photo
  def initialize(user, data)
    @user = user
    @data = data
  end

  def id
    @data['id'].to_s
  end

  def data
    flickr.photos.getInfo(photo_id: id).to_h
  end

  def exif
    flickr.photos.getExif(photo_id: id).to_h
  end

  def to_json
    JSON.pretty_generate data
  end

  def path
    @user.path + "photos" + id
  end

  def write(overwrite={})
    wrote = false
    print path.to_s.blue.bold
    FileUtils.mkdir_p path

    if !(path + 'data.json').exist? || overwrite[:data]
      File.write(path + 'data.json', to_json)
      print "\n  wrote ".grey + "data.json"
      wrote = true
    end

    if !(path + 'exif.json').exist? || overwrite[:exif]
      File.write(path + 'exif.json', JSON.pretty_generate(exif))
      print "\n  wrote ".grey + "exif.json"
      wrote = true
    end

    if !(path + 'photo_z.jpg').exist? || overwrite[:thumb]
      open @data['url_z'] do |f|
        File.write(path + 'photo_z.jpg', f.read)
      end
      print "\n  wrote ".grey + "thumbnail"
      wrote = true
    end

    if Pathname.glob(path + 'photo_o.*').size == 0 || overwrite[:original]
      open @data['url_o'] do |f|
        File.write(path + "photo_o.#{data['originalformat']}", f.read)
      end
      print "\n  wrote ".grey + "original"
      wrote = true
    end

    if wrote
      print "\n\n"
    else
      print "\r  skipped ".red + path.to_s.grey + "\n"
    end

    wrote
  end
end

class Set
  def initialize(user, data)
    @user = user
    @data = data
  end

  def id
    @data['id'].to_s
  end

  def title
    @data['title']
  end

  def photos
    @photos ||= flickr.photosets.getPhotos(photoset_id: id)['photo']
      .map {|hsh| hsh['id']}
  end

  def to_json
    JSON.pretty_generate(@data.to_h.merge(photos: photos))
  end

  def path
    @user.path + "sets" + id
  end

  def write
    wrote = false
    print path.to_s.blue.bold
    FileUtils.mkdir_p(path)

    unless (path + 'data.json').exist?
      File.write(path + 'data.json', to_json)
      print "\n  wrote ".grey + 'data.json'
      wrote = true
    end

    if wrote
      print "\n\n"
    else
      print "\r  skipped ".red + path.to_s.grey + "\n"
    end
  end
end

class User
  def initialize(id)
    @id = id.to_s
  end

  def path
    HERE + @id
  end

  def photos
    Seq::Paged.new do |page|
      opts = {
        user_id:  @id,
        per_page: 500, # max allowed by flickr
        page:     page,
        extras:   'url_z,url_o'
      }

      flickr.people.getPhotos(opts).to_a.map {|data| Photo.new(self, data) }
    end
  end

  def sets
    Seq::Paged.new do |page|
      opts = {
        user_id:  @id,
        per_page: 500,
        page:     page
      }

      flickr.photosets.getList(opts).to_a.map {|data| Set.new(self, data) }
    end
  end

  def data
    flickr.people.getInfo(user_id: @id).to_h
  end

  def to_json
    JSON.pretty_generate data
  end

  def write
    wrote = false
    print path.to_s.blue.bold
    FileUtils.mkdir_p(path)

    unless (path + 'data.json').exist?
      File.write(path + 'data.json', to_json)
      print "\n  wrote ".grey + 'data.json'
      wrote = true
    end

    if wrote
      print "\n\n"
    else
      print "\r  skipped ".red + path.to_s.grey + "\n"
    end

    wrote
  end
end


FlickRaw.api_key = ENV['FLICKR_KEY']
FlickRaw.shared_secret = ENV['FLICKR_SECRET']

Helper.authenticate
Helper.test_login

break_on_skip = true
user = User.new(Helper.login['id'])

user.write

user.sets.each do |set|
  break unless set
  break if !set.write && break_on_skip
  set.write if set
end

user.photos.each do |photo|
  break unless photo
  break if !photo.write && break_on_skip
end

puts "Done!".green
